% Opcje klasy 'iithesis' opisane sa w komentarzach w pliku klasy. Za ich pomoca
% ustawia sie przede wszystkim jezyk i rodzaj (lic/inz/mgr) pracy, oraz czy na
% drugiej stronie pracy ma byc skladany wzor oswiadczenia o autorskim wykonaniu.
\documentclass[inz, english, shortabstract]{iithesis}

\usepackage[utf8]{inputenc} 

%%%%% DANE DO STRONY TYTUŁOWEJ
% Niezaleznie od jezyka pracy wybranego w opcjach klasy, tytul i streszczenie
% pracy nalezy podac zarowno w jezyku polskim, jak i angielskim.
% Pamietaj o madrym (zgodnym z logicznym rozbiorem zdania oraz estetyka) recznym
% zlamaniu wierszy w temacie pracy, zwlaszcza tego w jezyku pracy. Uzyj do tego
% polecenia \fmlinebreak. 
\polishtitle    {Implementacja statycznej i dynamicznej semantyki rachunku z efektami algebraicznymi i ich obsługą z pomocą biblioteki \Redex}
\englishtitle   {Implementation of static and~dynamic semantics for a calculus with algebraic effects and~handlers using \Redex} 
\polishabstract {Abstrakt w języku polskim}
\englishabstract{English abstract}
%
\author         {Maciej Buszka}
%
\advisor        {dr hab. Dariusz Biernacki}
%\date          {}                     % Data zlozenia pracy
% Dane do oswiadczenia o autorskim wykonaniu
%\transcriptnum {}                     % Numer indeksu
\advisorgen     {dr. hab. Dariusza Biernackiego} % Nazwisko promotora w dopelniaczu
%%%%%

%%%%% WLASNE DODATKOWE PAKIETY
%
\let\lll\undefined
\usepackage{amsmath, amssymb, biblatex, float}

\usepackage[pdftex]{graphicx}
\addbibresource{mybib.bib}

\floatstyle{boxed} 
\restylefloat{figure}

%
%%%%% WŁASNE DEFINICJE I POLECENIA
%
%\theoremstyle{definition} \newtheorem{definition}{Definition}[chapter]
%\theoremstyle{remark} \newtheorem{remark}[definition]{Observation}
%\theoremstyle{plain} \newtheorem{theorem}[definition]{Theorem}
%\theoremstyle{plain} \newtheorem{lemma}[definition]{Lemma}
%\renewcommand \qedsymbol {\ensuremath{\square}}
% ...
%%%%%
\newcommand{\Redex}{\texttt{PLT Redex} }
\newcommand{\Racket}{\texttt{Racket} }
\newcommand{\LC}{\(\lambda\)-calculus }

\begin{document}

%%%%% POCZĄTEK ZASADNICZEGO TEKSTU PRACY

\chapter{Introduction}
% TODO add motivation, how it all relates to my work, what I did whats the point (what, how, why)
% thesis outline
% odrobina reklamy, dlaczego i po co.

% algebraic are trendy right now.

% something about redex in introduction, why what it gives us
% is redex suitable for more complicated languages
% how does automatic counterexample works

% dlaczego:
% experimentation with algebraic effects (calculus with various features)
% 
% lightweight prototyping

% goals:
% calculus
% implementation
% automatic testing (failed)

\begin{itemize}
  \item Algebraic effects and handlers
  \begin{itemize}
    \item What are algebraic effects
    \item Why do we need handlers
    \item 
  \end{itemize}
  
  \item Reduction semantics
  
  \item Type inference
  
  \item \Redex
  \begin{itemize}
    \item Defining languages, relations on terms, reduction semantics
    \item Automatic testing, counterexample search
  \end{itemize}
\end{itemize}

Algebraic effects \cite{Plotkin2003} are an increasingly popular technique of structuring computational effects.
They allow for seamless composition of multiple effects, while retaining (unlike monads) applicative style of programs.
Coupled with handlers \cite{Plotkin2013} which give programmers ability to interpret effects, they provide a great tool for abstracting over a set of operations which some program may perform and separating this interface from semantics of those operations defined as effect handlers.
% Paragraph about effect systems
While designing a calculus representing a core of programming language, one must be very careful deciding which features to add and keep in mind all the interactions between them.
Following most of the functional language designers I chose \LC as a basis extended with operation invocation, effect lifting and handling.
The type system for this calculus is defined in Curry style, which means that expressions do not contain types, which are assigned to them by the typing relation.
In more practical terms I had to implement type inference, instead of type checking.
Also besides the type system which specifies static semantics of calculus, one must specify the behavior of programs at run-time.
I chose the format of reduction semantics, as it is quite readable and is supported by \Redex library.

\section{Algebraic effects and handlers}
Algebraic effects and handlers are a language level framework which allow for coherent presentation, abstraction, composition and reasoning about computational effects.
The key idea is to separate invocation of an effectful operation in an expression from the meaning of such operation.
When one invokes an operation, current continuation is captured and passed along with operation's argument to nearest handler.
The handler in turn may execute arbitrary expression, using the continuation once, twice, returning a function which calls the continuation or simply ignoring it.
This way many control structures can be modeled and generalized by algebraic effects and appropriate handlers.
For example, the exceptions can be modeled using a single operation \texttt{throw} and a handler which either returns the result when computation succeeded or returns default value, ignoring passed continuation.
\begin{verbatim}
handle e with
| throw () r -> // return default value
| return x   -> x
end
\end{verbatim}
From the language design standpoint algebraic effects provide single implementation of various phenomena which may happen during execution of a program, for example mutable state, I/O, environment lookup, exceptions etc. in a sense that every effect is treated the same, the typing rules are defined for invocation of any operation, and handling of any operation.
Similarly the operational semantics is also quite simple and succinct thanks to uniform treatment of various effects.
This framework is also extendable. With small additions if can handle built-in effects in addition to user-defined ones.

From the language user perspective algebraic effects provide means of abstraction over effects used in a program.
Thanks to easy creation of new effects, one can define special purpose operations and their handlers to better represent domain specific problems while simultaneously using well known effects, defined in standard library.
With effects being tracked by the type system, programmers can enforce purity or specific set of used effects at compile-time, or using effect polymorphism they can write reusable functions which abstract over effects which may happen.
The separation of definition and implementation of effects allows for various interpretations of operations, similar to a technique of \emph{dependency-injection} used for example during testing.
% TODO anonymous vs defined effects, abstract effects, effect polymorphism

\section{Type inference}
Type inference is a technique of algorithmic reconstruction of types for various constructions used in a language.
It allows programmers to write programs with no type annotations, which often feel redundant and obfuscate the meaning of a program.
The most well known type system with inference is a system for \emph{ML} family of languages - \emph{Haskell}, \emph{OCaml}, \emph{SML} which infers the types with no annotations whatsoever.
Formal type system defines grammar of types consisting of base types (\texttt{int}, \texttt{bool} etc.), type constructors (arrows, algebraic data types) and type variables.
The typing rules require types which should be compatible (f.e. formal parameter and argument types) to unify.
The key feature of this system is so called let-polymorphism - generalization of types of let-bound variables.
This way code reuse can be accomplished without complicating the type system and compromising type safety.
The basis of implementation of this system is first order unification algorithm, which syntactically decomposes types and builds a substitution from type variables to types.

\section{Reduction semantics and abstract machines}
Reduction semantics is a format for specifying dynamic semantics of a calculus in an operational style.
The basic idea is to first define redexes - expressions which can be reduced, and contexts in which the reduction can happen.
\begin{align*}
  e &::= x \mid \lambda x . e \mid e e \\
  E &::= \square \mid E e
\end{align*}
Then we have to define reduction relation, which generates a transition system for terms in the calculus.
The rules usually take the form of redex in a context which reduces to some expression in a context.

\chapter{The calculus}
The calculus implemented in this thesis is based on lambda calculus with call-by-value semantics, similarly to other calculi which allow for computational effects, because fixed evaluation order is essential to obtaining sane program semantics.
Inspired by Links \cite{Hillerstrom2016} the operations are truly ad-hoc meaning that they don't have to be declared before usage.
Moreover the calculus requires no type annotations whatsoever in spirit of \emph{ML} family of languages while still tracking effects which occur in a program.

\section{Abstract syntax}
\begin{figure}
  \centering
  \includegraphics{language}
\end{figure}
Abstract syntax of comprises of forms standard to \LC ($\lambda$ abstractions, variables and applications), extended with number literals and primitive numerical operations (which allow for some example computation), and syntactic forms used by algebraic effects - operation invocations, handle expressions and lift expressions.
Inspired by calculus of Links described in ??? operations are a distinct syntactic category, while lift construct was introduced in Biernacki et. al. % TODO reference

\section{Static semantics}
The type system is based on Koka (Leijen's style of row types) and Links systems (ad-hoc operations).
As the calculus is defined in Curry-style the inference rules describe type reconstruction algorithm.

\subsection{Row types}
Row types as described in \cite{Leijen2005}

\subsection{Type inference}
The main judgment \emph{infer} infers a type and effect row, and calculates new substitution, given typing environment, current substitution and an expression.
As in \emph{ML} languages only simple types can be inferred, along with effect rows 

\subsection{Effect handlers}


\section{Dynamic semantics}

\section{Abstract machine}


\chapter{Implementation}

\section{\Redex}
% scaling problems

\section{Typing relation}

\section{Unification}

\section{Reduction relation}

\section{Automatic testing}


\chapter{The \Racket environment}

\section{Front-end}

\section{Back-end}

% TODO implementation architecture
\chapter{User's manual}

\printbibliography

%\begin{thebibliography}{1}
%\bibitem{example} \ldots
%\end{thebibliography}

\end{document}
