% Opcje klasy 'iithesis' opisane sa w komentarzach w pliku klasy. Za ich pomoca
% ustawia sie przede wszystkim jezyk i rodzaj (lic/inz/mgr) pracy, oraz czy na
% drugiej stronie pracy ma byc skladany wzor oswiadczenia o autorskim wykonaniu.
\documentclass[inz, english, shortabstract]{iithesis}

\usepackage[utf8]{inputenc}

%%%%% DANE DO STRONY TYTUŁOWEJ
% Niezaleznie od jezyka pracy wybranego w opcjach klasy, tytul i streszczenie
% pracy nalezy podac zarowno w jezyku polskim, jak i angielskim.
% Pamietaj o madrym (zgodnym z logicznym rozbiorem zdania oraz estetyka) recznym
% zlamaniu wierszy w temacie pracy, zwlaszcza tego w jezyku pracy. Uzyj do tego
% polecenia \fmlinebreak.
\polishtitle    {Implementacja statycznej i dynamicznej semantyki rachunku z efektami algebraicznymi i ich obsługą z pomocą biblioteki \Redex}
\englishtitle   {Implementation of static and~dynamic semantics for a calculus with algebraic effects and~handlers using \Redex} 
\polishabstract {Abstrakt w języku polskim}
\englishabstract{English abstract}
%
\author         {Maciej Buszka}
%
\advisor        {dr hab. Dariusz Biernacki}
%\date          {}                     % Data zlozenia pracy
% Dane do oswiadczenia o autorskim wykonaniu
%\transcriptnum {}                     % Numer indeksu
\advisorgen     {dr. hab. Dariusza Biernackiego} % Nazwisko promotora w dopelniaczu
%%%%%

%%%%% WLASNE DODATKOWE PAKIETY
%
%\usepackage{graphicx,listings,amsmath,amssymb,amsthm,amsfonts,tikz}
%
%%%%% WŁASNE DEFINICJE I POLECENIA
%
%\theoremstyle{definition} \newtheorem{definition}{Definition}[chapter]
%\theoremstyle{remark} \newtheorem{remark}[definition]{Observation}
%\theoremstyle{plain} \newtheorem{theorem}[definition]{Theorem}
%\theoremstyle{plain} \newtheorem{lemma}[definition]{Lemma}
%\renewcommand \qedsymbol {\ensuremath{\square}}
% ...
%%%%%
\newcommand{\Redex}{\texttt{PLT Redex} }
\newcommand{\Racket}{\texttt{Racket} }
\newcommand{\LC}{\(\lambda\)-calculus }

\begin{document}

%%%%% POCZĄTEK ZASADNICZEGO TEKSTU PRACY

\chapter{Introduction}
\begin{itemize}
  \item Algebraic effects and handlers
  \begin{itemize}
    \item What are algebraic effects
    \item Why do we need handlers
    \item 
  \end{itemize}
  
  \item Reduction semantics
  
  \item Type inference
  
  \item \Redex
  \begin{itemize}
    \item Defining languages, relations on terms, reduction semantics
    \item Automatic testing, counterexample search
  \end{itemize}
\end{itemize}

Algebraic effects \cite{Plotkin2003} are an increasingly popular technique of structuring computational effects.
They allow for seamless composition of multiple effects, while retaining (unlike monads) applicative style of programs.
Coupled with handlers \cite{Plotkin2013} which give programmers ability to interpret effects, they provide a great tool for abstracting over a set of operations which some program may perform and separating this interface from semantics of those operations defined as effect handlers.
% Paragraph about effect systems
While designing a calculus representing a core of programming language, one must be very careful deciding which features to add and keep in mind all the interactions between them.
Following most of the functional language designers I chose \LC as a basis extended with operation invocation, effect lifting and handling.
The type system for this calculus is defined in Curry style, which means that expressions do not contain types, which are assigned to them by the typing relation.
In more practical terms I had to implement type inference, instead of type checking.
Also besides the type system which specifies static semantics of calculus, one must specify the behavior of programs at runtime.
I chose the format of reduction semantics, as it is quite readable and is supported by \Redex library.

\section{Algebraic effects and handlers}

\section{Type inference}

\section{Reduction semantics and abstract machines}


\chapter{The calculus}

\section{Abstract syntax}

\section{Type system}

\section{Reduction semantics}

\section{Abstract machine}


\chapter{Implementation}

\section{\Redex}

\section{Typing relation}

\section{Unification}

\section{Reduction relation}

\section{Automatic testing}


\chapter{The \Racket environment}

\subsection{Front-end}

\subsection{Back-end}


\chapter{User's manual}


\bibliography{mybib}{}
\bibliographystyle{plain}

%\begin{thebibliography}{1}
%\bibitem{example} \ldots
%\end{thebibliography}

\end{document}
