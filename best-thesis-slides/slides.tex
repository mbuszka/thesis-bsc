\documentclass{beamer}

\mode<presentation>
{
  \usetheme{Warsaw}      % or try Darmstadt, Madrid, Warsaw, ...
  \usecolortheme{default} % or try albatross, beaver, crane, ...
  \usefonttheme{default}  % or try serif, structurebold, ...
  \setbeamertemplate{navigation symbols}{}
  \setbeamertemplate{caption}[numbered]
} 
\usepackage[polish]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fancyvrb}
\usepackage{fontspec}

\setmonofont{CMU Typewriter Text}

\newcommand{\Redex}{\texttt{PLT Redex}}
\newcommand{\Racket}{\texttt{Racket}}
\newcommand{\LC}{\(\lambda\)-calculus}

\title[A calculus with algebraic effects and~handlers]{Implementation of static and~dynamic semantics for a calculus with algebraic effects and~handlers using \Redex}
\author{Maciej Buszka}
\institute{Instytut Informatyki UWr}
\date{04.10.2019}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

% Na początek przedstawię kontekst mojej pracy, wyjaśniając niektóre słowa z tytułu, a także motywacje ku jej powstaniu.
% Następnie sformułuję cele które sobie postawiłem, a później opiszę wyniki które osiągnąłem.
% Na koniec podsumuję.
% \begin{frame}{Plan prezentacji}
%   \tableofcontents
% \end{frame}


\section{Kontekst}

\subsection{Formalizacja języków programowania}

% Dlaczego formalizować?
% Formalizacja wymusza dokładne zastanowienie się nad każdym elementem języka, rozważenie czy jest on potrzebny, wartościowy i nie duplikuje działania innego.
% Pozwala także na rozważenie wzajemnego oddziaływania wszystkich elementów języka.
% W ten sposób otrzymujemy język którego składowe mają dobrze zdefiniowane i przewidywalne zachowanie, są do siebie ortogonalne, a jednocześnie ich połączenie daje spójny wynik.
% Te cechy języka przekładają się na łatwiejsze utrzymanie i rozwój programów w nim napisanych.
% Narzędziem do formalizacji języków są rachunki formalne.
\begin{frame}{Formalizacja języków programowania}
  Wspiera:
  \begin{itemize}
    \item Przewidywalność
    \item Ortogonalność
    \item Spójność
  \end{itemize} 
  \vspace{\baselineskip}
  \textbf{Wynik}: łatwiejsze utrzymanie i rozwój programów \\ % systemów
  \vspace{\baselineskip}
  Narzędzie: rachunki formalne
\end{frame}


% % Znając narzędzia, przejdziemy do głównego zagadnienia poruszanego w mojej pracy, czyli efektów obliczeniowych.


\subsection{Efekty obliczeniowe}
\begin{frame}{Efekty obliczeniowe (\textit{side effects})}
  \begin{itemize}
    \item Zjawisko powszechne i znane każdemu programiście \\
    \texttt{print "Hello World!"}
    \item Zrozumienie działania programu wymaga nielokalnego wnioskowania
    \item Wpływ programu na otoczenie
    \item Dwie ogólne kategorie:
    \begin{itemize}
      \item Modyfikacja lub odczytanie stanu 
      % IO, baza danych, stan globalny programu, stan lokalny w językach funkcyjnych, generator liczb pseudolosowych)
      \pause
      \item Alternatywne ścieżki sterowania 
      % wyjątki, manipulacja kontynuacją
    \end{itemize}
  \end{itemize}
\end{frame}



\begin{frame}{Efekty obliczeniowe - podejścia konwencjonalne}
  \begin{itemize}
    \item Ignorowanie efektów
    \begin{itemize}
      \item C, C++, Java, OCaml, Scala
      \item Poważne błędy programów
      \item Niemożliwość wnioskowania równościowego
      \item Niejawne zależności między modułami
    \end{itemize}
    \pause
    \item Podzielenie języka na dwie części
    \begin{itemize}
      \item Nieprzyjazne dla nowych programistów
      \item Łączenie różnych efektów jest skomplikowane (np transformatory monad)
      \item Problem z dodaniem efektów \textit{post-factum}
    \end{itemize}
  \end{itemize}
\end{frame}



\begin{frame}[fragile]{Efekty algebraiczne}
  \begin{itemize}
    \item Jednolita składnia
    \item Pomocny system typów% : \\
    % Program
    % \begin{Verbatim}
    %   let x = Get 0
    %   let y = Get 1
    %   5 + (Put (x + y))
    % \end{Verbatim}
    % Korzysta z efektów \texttt{Get} oraz \texttt{Put}
    \item Kompozycja efektów
    \item Modelowanie obu kategorii
    % \pause
    \item Definicja własnych efektów
    % \pause
    \item Nowe, aktualnie rozwijane zagadnienie
  \end{itemize}
\end{frame}



% \begin{frame}{Efekty algebraiczne - wyzwania}
%   \begin{itemize}
%     \item Nowe, aktualnie rozwijane zagadnienie
%     \item Różne podejścia w literaturze:
%     \begin{itemize}
%       \item Semantyka statyczna: row-types, capabilities, abstract effects
%       \item Semantyka dynamiczna: shallow/deep handlers, effect lifting
%     \end{itemize}
%     \item Skomplikowana semantyka, ważne niuanse
%     \item Wiele rozbudowanych języków eksperymentalnych: Koka, Helium, Eff, Frank, Links
%   \end{itemize}
% \end{frame}


% \section{Motywacja}
% TODO Przenieść i wpleść w kontekst
% \begin{frame}{Motywacja}
%   \begin{itemize}
%     \item Nowe, aktywnie rozwijane zagadnienie
%     % \pause
%     \item Nietrywialna semantyka i implementacja
%     % \pause
%     \item Skomplikowane ciągi redukcji
%     % \pause
%     \item Brak interaktywnego modelu rachunku
%     % \pause
%   \end{itemize}
% \end{frame}

\section{Cel}
\begin{frame}{Cel pracy}
  \begin{itemize}
    \item Stworzenie formalnego rachunku
    % \pause
    \begin{itemize}
      \item Efekty algebraiczne
      \item Konstrukcje bazowe
    \end{itemize}
    % \pause
    \item Implementacja modelu
    \begin{itemize}
      \item Algorytmiczna inferencja typu i efektów
      \item Obrazowanie wykonania krok po kroku
    \end{itemize}
  \end{itemize}
\end{frame}


\section{Wynik}


\subsection{Rachunek}
\begin{frame}{Rachunek}
  \begin{itemize}
    \item Abstrakcyjne operacje
    \begin{itemize}
      \item Nie muszą być zdefiniowane a priori
      \item Przyjmują jeden argument, zwracają jedną wartość
    \end{itemize}
    % \pause
    \item Wyrażenia obsługujące (\emph{handler})
    \begin{itemize}
      \item Dostęp do wznowienia
      \item Semantyka tzw. głębokiej obsługi
      \item Obsługa wielu operacji naraz
      \item Klauzula \texttt{return}
    \end{itemize}
    % \pause
    \item Wyrażenia podnoszące (\emph{lift})
    \begin{itemize}
      \item 'przeskoczenie' najbliższego wyrażenia obsługującego
    \end{itemize}
    % \pause
    \item Wartości bazowe oraz operacje na nich
  \end{itemize}
\end{frame}


\subsection{Model}
\begin{frame}{Model}
  \begin{itemize}
    \item Zaimplementowany za pomocą biblioteki \Redex
    \item Składnia abstrakcyjna
    \begin{itemize}
      \item Dodatkowo: przyjazny język
    \end{itemize}
    \item System typów
    \begin{itemize}
      \item Algorytmiczna inferencja typu i efektów wyrażenia
    \end{itemize}
    \item Relacja redukcji
    \begin{itemize}
      \item Wykonanie krok po kroku
    \end{itemize}
    % \pause
    \item Maszyna abstrakcyjna
    \begin{itemize}
      \item Jawne środowisko
      \item Zgodność z relacją redukcji
    \end{itemize}
    \item Testy
  \end{itemize}
\end{frame}

% Raczej opisać jak można wykorzystać model, co daje, pod innym kątem, coś o testowaniu, potencjalne perspektywy, co można by rozwinąć
% Zrobić prawdziwe podsumowanie albo zmienić tytuł


\section{Podsumowanie}
\begin{frame}{Podsumowanie}
  Wynik:
  \begin{itemize}
    \item Formalny rachunek z efektami algebraicznymi
    \item Wykonywalny model rachunku
    \begin{itemize}
      \item Wizualizacja przekształceń
      \item Inferencja typu i efektów
    \end{itemize}
  \end{itemize}
  \vspace{\baselineskip}
  Możliwości modelu:
  \begin{itemize}
    \item Iteracyjna rozbudowa rachunku
    \item Testowanie semantyki
  \end{itemize}
\end{frame}

\begin{frame}
  \centering
  Dziękuję za uwagę
\end{frame}

\begin{frame}
  \titlepage
\end{frame}


% %% DO PRZESUNIECIA

% % Wiedząc już na czym polega formalizacja, czas przyjrzeć się głównemu narzędziu z którego korzystałem.
% % Biblioteka PLT Redex pozwala na zdefiniowanie składni rachunku oraz zadanie systemu typów w postaci reguł wnioskowania.
% % Następnie można skonstruować relację redukcji, która opisuje wykonanie programów.
% % Dzięki temu, że wszystkie elementy modelu są wykonywalne, dużo łatwiej jest na bieżąco sprawdzać zachowanie semantyki, co przekłada się na możliwość pracy iteracyjnej i łatwiejsze doskonalenie rachunku.
% % Pomagają w tym także testy, zarówno pisane ręcznie jak i wspomagane przez automatyczne generowanie kontrprzykładów przez bibliotekę.
% % Jednocześnie powstały model pozwala na zrozumienie semantyki i interakcji fragmentów składni innym osobom, poprzez bezpośrednią obserwację wykonania programu krok po kroku.
% \subsection{\Redex}
% \begin{frame}{\Redex}
%   \begin{itemize}
%     \item Biblioteka do języka \Racket
%     \item Modelowanie rachunku i jego semantyki
%     \begin{itemize}
%       \item Wykonywalne relacje
%       \item Czytelny opis tych relacji
%     \end{itemize}
%     \item Testowanie semantyki
%     \item Iteracyjny rozwój rachunku
%   \end{itemize}
% \end{frame}

% %% DO USUNIECIA (RACZEJ)

% % Wszystko rozpoczyna się od zdefiniowania składni abstrakcyjnej, czyli reguł tworzenia programów zwanych także wyrażeniami.
% % Te właściwości programów, które można zbadać bez ich uruchamiania są opisywane przez semantykę statyczną, najczęściej w postaci systemu typów.
% % Natomiast zachowanie wyrażeń w trakcie wykonania jest opisywane przez semantykę dynamiczną, np relację redukcji albo maszynę abstrakcyjną.
% % Mając sformalizowany rachunek, zapewniliśmy cechy które wymieniłem wcześniej, ale to jeszcze nie wszystko co można osiągnąć.
% % Kolejnym krokiem może być udowodnienie interesujących nas właściwości języka, a co za tym idzie faktów o programach które można w nim napisać.
% \begin{frame}{Formalizacja rachunku}
%   Narzędzia do formalnego opisu języka:
%   \begin{itemize}
%     \item Składnia abstrakcyjna
%     \item Semantyka statyczna (głównie systemy typów)
%     \item Semantyka dynamiczna (definiuje wykonanie programu)
%   \end{itemize}
%   Dodatkowo: udowodnione własności
% \end{frame}

\end{document}
