\documentclass{beamer}

\mode<presentation>
{
  \usetheme{Warsaw}      % or try Darmstadt, Madrid, Warsaw, ...
  \usecolortheme{default} % or try albatross, beaver, crane, ...
  \usefonttheme{default}  % or try serif, structurebold, ...
  \setbeamertemplate{navigation symbols}{}
  \setbeamertemplate{caption}[numbered]
} 
\usepackage[polish]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fancyvrb}
\usepackage{fontspec}

\setmonofont{CMU Typewriter Text}

\newcommand{\Redex}{\texttt{PLT Redex}}
\newcommand{\Racket}{\texttt{Racket}}
\newcommand{\LC}{\(\lambda\)-calculus}

\title[A calculus with algebraic effects and~handlers]{Implementation of static and~dynamic semantics for a calculus with algebraic effects and~handlers using \Redex}
\author{Maciej Buszka}
\institute{Instytut Informatyki UWr}
\date{04.10.2019}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

% Na początek wyjaśnię słowa które znalazły się w tytule tej prezentacji i co się za nimi kryje.
% Zarysowując kontekst mojej pracy, przedstawię także motywacje ku jej powstaniu.
% Następnie sformułuję cele które sobie postawiłem, a później opiszę wyniki które osiągnąłem.
% Na koniec podsumuję.
\begin{frame}{Plan prezentacji}
  \tableofcontents
\end{frame}


\section{Kontekst}

\subsection{Formalizacja języków programowania}

% Dlaczego formalizować?
% Formalizacja wymusza dokładne zastanowienie się nad każdym elementem języka, rozważenie czy jest on potrzebny, wartościowy i nie duplikuje działania innego.
% Pozwala także na rozważenie wzajemnego oddziaływania wszystkich elementów języka.
% W ten sposób otrzymujemy język którego składowe mają dobrze zdefiniowane i przewidywalne zachowanie, są do siebie ortogonalne, a jednocześnie ich połączenie daje spójny wynik.
% Te cechy języka przekładają się na łatwiejsze utrzymanie i rozwój programów w nim napisanych.
% Narzędziem do formalizacji języków są rachunki formalne.
% % Umożliwiają one także dowodzenie własności języka, a co za tym idzie programów własności programów w nim napisanych.
\begin{frame}{Formalizacja języków programowania}
  Wspiera:
  \begin{itemize}
    \item Ortogonalność
    \item Przewidywalność
    \item Spójność
  \end{itemize} 
  \vspace{\baselineskip}
  \textbf{Wynik}: łatwiejsze utrzymanie i rozwój programów \\ % systemów
  % \textbf{Dodatkowo}: udowodnienie własności
\end{frame}


% % Znając narzędzia, przejdziemy do głównego zagadnienia poruszanego w mojej pracy, czyli efektów obliczeniowych.

% Efekty obliczeniowe, z angielskiego side effects to główne zagadnienie poruszane w mojej pracy.
% Jest to zjawisko z którym programiści zmagają się od początków istnienia języków programowania.
% Źródło wielu błędów, frustracji i nieporozumień odbiera im podstawowe narzędzie do wnioskowania, czyli możliwość podzielenia programu na mniejsze części i zrozumienia ich oddzielnie, a następnie połączenia ich działań.
% Wynika to bezpośrednio z bardzo ogólnej definicji czym są efekty obliczeniowe, czyli interakcji z otoczeniem.
% Niejawne zależności między fragmentami większego systemu na ogół można przypisać do dwóch kategorii.
% Pierwszą z nich jest modyfikacja jakiegoś stanu lub jego sprawdzenie.
% Przykładami są tutaj problemy wejścia-wyjścia, komunikacji z bazą danych, generacją liczb pseudolosowych, czy też wykorzystania zmiennych.
% Dodatkową komplikacją przy efektach związanych ze stanem jest zachowanie programów współbieżnych, czy też działających asynchronicznie.
% Drugą kategorię tworzą zmiany przepływu sterowania, na przykład wyjątki.
\subsection{Efekty obliczeniowe}
\begin{frame}{Efekty obliczeniowe (\textit{side effects})}
  \begin{itemize}
    \item Zjawisko powszechne i znane każdemu programiście \\
    \texttt{print "Hello World!"}
    \item Zrozumienie działania programu wymaga nielokalnego wnioskowania
    \item Wpływ programu na otoczenie
    \item Dwie ogólne kategorie:
    \begin{itemize}
      \item Modyfikacja lub odczytanie stanu 
      % IO, baza danych, stan globalny programu, stan lokalny w językach funkcyjnych, generator liczb pseudolosowych)
      \item Alternatywne ścieżki sterowania 
      % wyjątki, manipulacja kontynuacją
    \end{itemize}
  \end{itemize}
\end{frame}


% Dwa konwencjonalne podejścia do efektów obliczeniowych, które można zaobserwować w systemach typów różnych języków programowania pozostawiają wiele do życzenia.
% Pierwsze z nich, jest względnie najprostsze z punktu widzenia implementacji a zarazem najpowszechniejsze.
% Jest to oczywiście ignorowanie problemu.
% Systemy typów języków zarówno imperatywnych takich jak C, C++, obiektowych jak Java oraz funkcyjnych jak OCaml i Scala nie dają żadnej wskazówki programistom na temat efektów które mogą zostać spowodowane przez funkcje czy metody.
% Programiście pozostaje uważne czytanie dokumentacji i podejrzliwość wobec funkcji nie zwracających żadnych wartości.
% (tutaj nie jestem pewien) (przypadek funkcji mapValues w Scali)
% Drugie podejście, znane z języka Haskell, to uznanie, że większość języka będzie czysta, a część funkcji które muszą spowodować efekty będą zwracały specjalny typ.
% Programiści mają do dyspozycji specjalne operacje pozwalające łączyć takie funkcje oraz dedykowaną składnię, która ułatwia pisanie programów z efektami.
% To rozwiązanie też nie jest bez wad, istotniejsze z nich to specjalna składnia dla programów z efektami, skomplikowane rozwiązania problemu łączenia różnych efektów, a także bardzo uciążliwe dodawanie efektów do czystego wyrażenia post-factum.
\begin{frame}{Efekty obliczeniowe - podejścia konwencjonalne}
  \begin{itemize}
    \item Program może mieć dowolne efekty, a system typów się nimi nie interesuje (C, C++, Java ..., OCaml, Scala)
    \begin{itemize}
      \item Brak pewności co do zachowania funkcji
      \item Niemożliwość wnioskowania równościowego
      \item Niejawne zależności między programami
    \end{itemize}
    \item Język jest czysty, a programy z efektami są modelowane za pomocą monad (Haskell, PureScript)
    \begin{itemize}
      \item Osobna składnia dla programów z efektami
      \item Łączenie różnych efektów jest skomplikowane (np transformatory monad)
      \item Problem z dodaniem efektów \textit{post-factum}
    \end{itemize}
  \end{itemize}
\end{frame}


% Jedną z odpowiedzi na problemy klasycznych rozwiązań są tak zwane efekty algebraiczne.
% Zapewniają one jednolitą składnię dla programów zarówno z jak i bez efektów.
% Pozwalają na stworzenie systemu typów który informuje programistę jakie efekty mogą zostać wywołane przez dany program, a także może zagwarantować, że dana funkcja nie wywołuje żadnych efektów obliczeniowych.
% Przykładowo, dla podanego programu algorytm wykryje, że korzysta on z dwóch operacji, get i put, które obie przyjmują i zwracają liczbę, a wynikiem całego programu także jest liczba.
% Efekty algebraiczne umożliwiają także bezproblemowe łączenie różnych efektów i mogą zostać użyte do modelowania obu wymienionych wcześniej kategorii.
% Dodatkowo umożliwiają one nadanie różnych interpretacji jednemu programowi, a także opis problemu z dziedziny za pomocą zbioru operacji.
\begin{frame}[fragile]{Efekty algebraiczne - możliwości}
  \begin{itemize}
    \item Jednolita składnia
    \item Pomocny system typów: \\
    Program
    \begin{Verbatim}
      let x = Get 0 in
      let y = Get 1 in
      5 + (Put (x + y))
    \end{Verbatim}
    Ma typ \texttt{Num} i korzysta z efektów \texttt{Get} oraz \texttt{Put}
    \item Kompozycja efektów
    \item Modelowanie obu kategorii
    % \pause
    \item Definicja własnych efektów
    % \pause
  \end{itemize}
\end{frame}


% Języki z efektami algebraicznymi mają na razie status eksperymentalny, a biblioteki do istniejących języków borykają się z różnymi problemami z modelowaniem.
% Jest tak, ponieważ efekty algebraiczne są wciąż nowym zagadnieniem, które jest aktywnie rozwijane przez wiele zespołów.
% W literaturze można znaleźć wiele pomysłów i rozwiązań zarówno w zakresie semantyki statycznej jak i dynamicznej.
% Różne połączenia tych elementów potrafią dać bardzo różne zachowania programów.
% Jednocześnie pomimo istnienia wielu języków, oraz formalnych rachunków na których bazie są zbudowane, nie jest łatwo zaobserwować i dokładnie zrozumieć jak wybory semantyczne przekładają się na zachowanie danego rachunku jako, że ich formalizacje nie są interaktywne.
\begin{frame}{Efekty algebraiczne - wyzwania}
  \begin{itemize}
    \item Nowe, aktualnie rozwijane zagadnienie
    \item Dość skomplikowana semantyka, ważne niuanse 
    \item Różne podejścia w literaturze:
    \begin{itemize}
      \item Semantyka statyczna: row-types, capabilities, abstract effects
      \item Semantyka dynamiczna: shallow/deep handlers, effect lifting
    \end{itemize}
    \item Wiele rozbudowanych języków eksperymentalnych: Koka, Helium, Eff, Frank, Links
  \end{itemize}
\end{frame}


% \section{Motywacja}
% TODO Przenieść i wpleść w kontekst
% \begin{frame}{Motywacja}
%   \begin{itemize}
%     \item Nowe, aktywnie rozwijane zagadnienie
%     % \pause
%     \item Nietrywialna semantyka i implementacja
%     % \pause
%     \item Skomplikowane ciągi redukcji
%     % \pause
%     \item Brak interaktywnego modelu rachunku
%     % \pause
%   \end{itemize}
% \end{frame}

\section{Cel}
% Wobec tego postanowiłem stworzyć przykładowy rachunek zawierający konstrukcje pozwalające na pracę z efektami algebraicznymi.
% W jego skład wchodzi system typów ułatwiający zarówno pracę z efektami jak i ich zrozumienie oraz relacja redukcji nadająca semantykę dynamiczną.
% Aby rachunek był użyteczny zaimplementowałem także jego model.
% Implementacja systemu typów pozwala na algorytmiczną inferencję typu i efektu wyrażenia, natomiast ewaluator umożliwia obserwację dynamicznego zachowania efektów algebraicznych krok po kroku.
\begin{frame}{Cel pracy}
  \begin{itemize}
    \item Stworzenie formalnego rachunku:
    % \pause
    \begin{itemize}
      \item Efekty algebraiczne
      \item Pomocny system typów
      \item Relacja redukcji
    \end{itemize}
    % \pause
    \item Implementacja modelu
    \begin{itemize}
      \item Algorytmiczna inferencja typu i efektu
      \item Ewaluator wyrażeń rachunku
      \begin{itemize}
        \item Obrazowanie wykonania krok po kroku
        \item Redukcja do wyniku końcowego
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}


\section{Wynik}

% Rachunek umożliwia programiście korzystanie z efektów algebraicznych za pomocą trzech konstrukcji językowych.
% Pierwsza z nich to abstrakcyjne operacje.
% Nie muszą być one zdefiniowane przed użyciem, a z punktu widzenia używającego ich wyrażenia przyjmują jeden argument i zwracają jedną wartość.
% Zbiór operacji użytych w danym wyrażeniu tworzy interfejs, którego implementacji dostarczają wyrażenia obsługujące, z angielskiego handler.
% Mają one dostęp do wznowienia przerwanego obliczenia i realizują semantykę głębokiej obsługi, a więc będą także obsługiwać operacje użyte we wznowieniu.
% Umożliwiają obsługę wielu operacji na raz, a także zmianę wartości końcowej dzięki klauzuli return.
% Trzecim składnikiem są wyrażenia podnoszące, z angielskiego lift które pozwalają na przeskoczenie najbliższego w trakcie wykonania wyrażenia obsługującego daną operację.
% W rachunku znajdują się także typy bazowe takie jak liczby, wartości boolowskie i listy, oraz operacje na nich.
% Dla tego rachunku stworzyłem także model, korzystając z biblioteki PLT Redex.
\subsection{Rachunek}
\begin{frame}{Rachunek}
  \begin{itemize}
    \item Abstrakcyjne operacje
    \begin{itemize}
      \item Nie muszą być zdefiniowane a priori
      \item Przyjmują jeden argument, zwracają jedną wartość
    \end{itemize}
    % \pause
    \item Wyrażenia obsługujące (\emph{handler})
    \begin{itemize}
      \item Dostęp do wznowienia
      \item Semantyka tzw. głębokiej obsługi
      \item Obsługa wielu operacji naraz
      \item Klauzula \texttt{return}
    \end{itemize}
    % \pause
    \item Wyrażenia podnoszące (\emph{lift})
    \begin{itemize}
      \item 'przeskoczenie' najbliższego wyrażenia obsługującego
    \end{itemize}
    % \pause
    \item Wartości bazowe oraz operacje na nich
  \end{itemize}
\end{frame}


% Model implementuje składnię abstrakcyjną rachunku, ale dodatkowo zbudowałem parser który pozwala pisać programy w przyjaznej składni podobnej do MLa.
% Implementacja semantyki statycznej, czyli systemu typów, rachunku pozwala na algorytmiczną inferencję typu a także efektów wyrażenia, natomiast relacja redukcji definiująca semantykę dynamiczną umożliwia zarówno pełną ewaluację wyrażeń, jak i obserwację każdego przekształcenia.
% Dodatkowo rozszerzyłem rachunek o maszynę abstrakcyjną, a model o jej implementację w postaci deterministycznego systemu przejść.
% Operuje ona na jawnym środowisku, a przepływ sterowania realizuje za pomocą stosu i meta-stosu.
% Zgodność maszyny abstrakcyjnej z relacją redukcji sprawdziłem za pomocą testów.
% Dodatkowo w trakcie implementacji modelu i rozwoju rachunku korzystałem z automatycznego generowania kontrprzykładów przez bibliotekę Redex, co pozwoliło mi wykryć i poprawić błędy.
\subsection{Model}
\begin{frame}{Model}
  \begin{itemize}
    \item Składnia abstrakcyjna
    \begin{itemize}
      \item Dodatkowo: przyjazny język
    \end{itemize}
    \item System typów
    \begin{itemize}
      \item Algorytmiczna inferencja typu i efektów wyrażenia
    \end{itemize}
    \item Relacja redukcji
    \begin{itemize}
      \item Wykonanie krok po kroku
    \end{itemize}
    % \pause
    \item Maszyna abstrakcyjna
    \begin{itemize}
      \item Jawne środowisko
    \end{itemize}
    \item Testy
  \end{itemize}
\end{frame}

% Raczej opisać jak można wykorzystać model, co daje, pod innym kątem, coś o testowaniu, potencjalne perspektywy, co można by rozwinąć
% Zrobić prawdziwe podsumowanie albo zmienić tytuł

% Podsumowując, w mojej pracy stworzyłem formalny rachunek, oraz niewielki język programowania na nim bazujący.
% Rachunek ten bada zachowanie efektów algebraicznych, czyli nowego i obiecującego rozwiązania problemów związanych z efektami obliczeniowymi.
% Wykonywalny model tego rachunku pozwala na zrozumienie działania efektów algebraicznych dzięki obrazowaniu wykonania krok po kroku.
% Ukazuje potencjał tego rozwiązania dzięki algorytmicznej inferencji typów i efektów, a także może stanowić podstawę do dalszych badań dzięki łatwiejszej pracy iteracyjnej i możliwości testowania.
% Dalsza praca nad tym rachunkiem mogłaby objąć rozszerzenie go o polimorfizm.
\section{Podsumowanie}
\begin{frame}{Podsumowanie}
  Wynik:
  \begin{itemize}
    \item Formalny rachunek z efektami algebraicznymi
    \item Wykonywalny model rachunku
  \end{itemize}
  \vspace{\baselineskip}
  Zastosowania:
  \begin{itemize}
    \item Edukacja
    \begin{itemize}
      \item Inferencja typu i efektów
      \item Wizualizacja przekształceń
    \end{itemize}
    \item Eksploracja
    \begin{itemize}
      \item Iteracyjna rozbudowa
      \item Testy
    \end{itemize}
  \end{itemize}
  Dalsza praca: rozszerzenie o polimorfizm
\end{frame}

\begin{frame}
  \centering
  Dziękuję za uwagę
\end{frame}

\begin{frame}
  \titlepage
\end{frame}


% %% DO PRZESUNIECIA

% % Wiedząc już na czym polega formalizacja, czas przyjrzeć się głównemu narzędziu z którego korzystałem.
% % Biblioteka PLT Redex pozwala na zdefiniowanie składni rachunku oraz zadanie systemu typów w postaci reguł wnioskowania.
% % Następnie można skonstruować relację redukcji, która opisuje wykonanie programów.
% % Dzięki temu, że wszystkie elementy modelu są wykonywalne, dużo łatwiej jest na bieżąco sprawdzać zachowanie semantyki, co przekłada się na możliwość pracy iteracyjnej i łatwiejsze doskonalenie rachunku.
% % Pomagają w tym także testy, zarówno pisane ręcznie jak i wspomagane przez automatyczne generowanie kontrprzykładów przez bibliotekę.
% % Jednocześnie powstały model pozwala na zrozumienie semantyki i interakcji fragmentów składni innym osobom, poprzez bezpośrednią obserwację wykonania programu krok po kroku.
% \subsection{\Redex}
% \begin{frame}{\Redex}
%   \begin{itemize}
%     \item Biblioteka do języka \Racket
%     \item Modelowanie rachunku i jego semantyki
%     \begin{itemize}
%       \item Wykonywalne relacje
%       \item Czytelny opis tych relacji
%     \end{itemize}
%     \item Testowanie semantyki
%     \item Iteracyjny rozwój rachunku
%   \end{itemize}
% \end{frame}

% %% DO USUNIECIA (RACZEJ)

% % Wszystko rozpoczyna się od zdefiniowania składni abstrakcyjnej, czyli reguł tworzenia programów zwanych także wyrażeniami.
% % Te właściwości programów, które można zbadać bez ich uruchamiania są opisywane przez semantykę statyczną, najczęściej w postaci systemu typów.
% % Natomiast zachowanie wyrażeń w trakcie wykonania jest opisywane przez semantykę dynamiczną, np relację redukcji albo maszynę abstrakcyjną.
% % Mając sformalizowany rachunek, zapewniliśmy cechy które wymieniłem wcześniej, ale to jeszcze nie wszystko co można osiągnąć.
% % Kolejnym krokiem może być udowodnienie interesujących nas właściwości języka, a co za tym idzie faktów o programach które można w nim napisać.
% \begin{frame}{Formalizacja rachunku}
%   Narzędzia do formalnego opisu języka:
%   \begin{itemize}
%     \item Składnia abstrakcyjna
%     \item Semantyka statyczna (głównie systemy typów)
%     \item Semantyka dynamiczna (definiuje wykonanie programu)
%   \end{itemize}
%   Dodatkowo: udowodnione własności
% \end{frame}

\end{document}
